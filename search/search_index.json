{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DeepMatch","text":"<p>DeepMatch keeps your Android deeplinks consistent from configuration to runtime. The Gradle plugin parses a <code>.deeplinks.yml</code> file and generates Kotlin sources plus optional manifest entries, while the runtime library matches incoming URIs and returns strongly-typed params.</p>"},{"location":"#key-components","title":"Key Components","text":"<ul> <li>deepmatch-plugin \u2014 Gradle plugin you apply to Android modules to parse specs and generate code.</li> <li>deepmatch-processor \u2014 Runtime matcher that maps URIs to specs and builds parameter objects.</li> <li>deepmatch-api \u2014 Shared spec/parameter data models used across plugin and runtime.</li> <li>deepmatch-testing \u2014 Reusable fixtures that assist in unit testing DeepMatch integrations.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Apply the plugin alongside your Android/Kotlin plugins and enable manifest generation if desired.</li> <li>Describe deeplinks in <code>.deeplinks.yml</code>; both module-level and variant-specific files are supported.</li> <li>Call the generated module processor (for example, <code>AppDeeplinkProcessor</code>) and use <code>match(uri)</code>    to retrieve parsed params. Generated params classes share a module-level sealed interface (for    example, <code>AppDeeplinkParams</code>) so your app can use exhaustive <code>when</code> matching.</li> </ol> <p>For detailed configuration options, see the navigation links for the Gradle plugin and YAML schema.</p>"},{"location":"#upgrading","title":"Upgrading","text":"<ul> <li>Check Release Notes for version-specific changes.</li> <li>For the runtime refactor in <code>0.2.0-alpha</code>, follow Migration Guide.</li> </ul>"},{"location":"#building-the-documentation","title":"Building the Documentation","text":"<pre><code>pip install -r docs/requirements.txt  # once\nmkdocs serve                            # start live-reloading docs site\n</code></pre> <p>The documentation is built with Material for MkDocs.</p>"},{"location":"config_file/","title":"YAML Spec","text":""},{"location":"config_file/#deeplink-configuration-object-deeplinkconfig","title":"Deeplink Configuration Object (<code>DeeplinkConfig</code>)","text":"<p>Each item in the <code>deeplinkSpecs</code> list is a deep link configuration object with the following properties, corresponding to the fields in your <code>DeeplinkConfig</code> Kotlin class:</p> <ul> <li> <p><code>name</code>: (Required, String)</p> <ul> <li>A unique identifier for this deep link specification. This name is used to generate stable spec/params types.</li> <li>Example: <code>userProfile</code>, <code>productView</code></li> </ul> </li> <li> <p><code>activity</code>: (Required, String)</p> <ul> <li>The fully qualified name of the Android Activity that will be primarily associated with this deep link in the <code>AndroidManifest.xml</code>.</li> <li>Example: <code>com.example.myapp.MainActivity</code>, <code>com.example.myapp.ProductDetailsActivity</code></li> </ul> </li> <li> <p><code>categories</code>: (Optional, List of Strings, defaults to <code>[\"DEFAULT\"]</code>)</p> <ul> <li>A list of intent filter categories to be added to the generated <code>&lt;intent-filter&gt;</code> in the <code>AndroidManifest.xml</code>.</li> <li>Valid values correspond to <code>IntentFilterCategory</code> enum (e.g., <code>DEFAULT</code>, <code>BROWSABLE</code>). The YAML value should be the string representation of the enum constant.</li> <li>Example: <code>categories: [DEFAULT, BROWSABLE]</code></li> <li>If omitted, it defaults to <code>[DEFAULT]</code>.</li> </ul> </li> <li> <p><code>autoVerify</code>: (Optional, Boolean, defaults to <code>false</code>)</p> <ul> <li>If set to <code>true</code>, the <code>android:autoVerify=\"true\"</code> attribute will be added to the generated <code>&lt;intent-filter&gt;</code>. This is necessary for Android App Links.</li> <li>Example: <code>autoVerify: true</code></li> </ul> </li> <li> <p><code>scheme</code>: (Required, List of Strings)</p> <ul> <li>One or more URI schemes supported by the deeplink.</li> <li>Example: <code>scheme: [myapp, https]</code></li> </ul> </li> <li> <p><code>host</code>: (Required, List of Strings)</p> <ul> <li>One or more hosts (domains) that should resolve to this deeplink.</li> <li>Example: <code>host: [\"example.com\", \"m.example.com\"]</code></li> </ul> </li> <li> <p><code>pathParams</code>: (Optional, List of Param objects)</p> <ul> <li>Defines ordered parameters that are part of the URI path. Each item in the list is a <code>Param</code> object.</li> <li>Param Object Structure:<ul> <li><code>name</code>: (Required, String) The name of the path parameter (e.g., <code>userId</code>, <code>itemId</code>). This is how you'll refer to it in generated params.</li> <li><code>type</code>: (Optional, String) The expected data type of the parameter. When provided, the generated matcher validates the segment against the type\u2019s regex and the runtime converts the value to the corresponding Kotlin type.</li> </ul> </li> <li>Example:     ```yaml     pathParams:<ul> <li>name: user</li> <li>name: userId     type: alphanumeric ```</li> </ul> </li> </ul> </li> <li> <p><code>queryParams</code>: (Optional, List of Param objects)</p> <ul> <li>Mirrors the structure of <code>pathParams</code> but for query string parameters.</li> <li>Query params should declare a <code>type</code> so the generated regex and parameter class enforce the expected format and type conversion.</li> <li>Example:     ```yaml     queryParams:<ul> <li>name: ref     type: string</li> <li>name: page     type: numeric ```</li> </ul> </li> </ul> </li> <li> <p><code>fragment</code>: (Optional, String)</p> <ul> <li>Adds a fragment requirement (<code>#details</code>). When provided, the generated parameter class exposes it as a property.</li> </ul> </li> <li> <p><code>description</code>: (Optional, String)</p> <ul> <li>Free-form text to describe the deeplink\u2019s purpose. Currently informational only.</li> </ul> </li> </ul>"},{"location":"config_file/#complete-example","title":"Complete Example","text":"<pre><code>deeplinkSpecs:\n  - name: \"open profile\"\n    description: \"Navigate to a user profile page\"\n    activity: com.example.app.MainActivity\n    autoVerify: true\n    categories: [DEFAULT, BROWSABLE]\n    scheme: [https, app]\n    host: [\"example.com\"]\n    pathParams:\n      - name: users\n      - name: userId\n        type: alphanumeric\n    queryParams:\n      - name: ref\n        type: string\n    fragment: \"details\"\n</code></pre>"},{"location":"config_file/#tips","title":"Tips","text":"<ul> <li>Keep <code>name</code> values unique per spec to simplify generated type naming and runtime routing.</li> <li>Regenerate sources (<code>./gradlew generate&lt;Variant&gt;DeeplinkSpecs</code>) whenever you modify the YAML schema.</li> <li>If <code>generateManifestFiles</code> is disabled, remember to replicate the <code>&lt;intent-filter&gt;</code> changes manually in your main manifest.</li> <li>When a deeplink declares typed path, query, or fragment values, the plugin also creates a <code>&lt;Name&gt;DeeplinkParams</code> class so your app receives strongly typed arguments after calling <code>match(uri)</code>.</li> <li>All generated params classes implement a module-level sealed interface named from the module name (for example, module <code>app</code> -&gt; <code>AppDeeplinkParams</code>), enabling exhaustive <code>when</code> checks.</li> <li>The plugin also generates a module-level processor object named from the module name (for example, module <code>app</code> -&gt; <code>AppDeeplinkProcessor</code>) preloaded with all generated specs.</li> </ul>"},{"location":"gradle_plugin/","title":"Gradle Plugin","text":""},{"location":"gradle_plugin/#core-capabilities","title":"Core Capabilities","text":"<p>The primary responsibilities and capabilities of the DeepMatch Gradle plugin are:</p> <ol> <li> <p>YAML Configuration Parsing:</p> <ul> <li>The plugin automatically locates and reads your <code>.deeplinks.yml</code> file (by default, from the root of the module, e.g., <code>app/.deeplinks.yml</code>, but this is configurable).</li> <li>It parses the YAML content, validating its structure against the expected format (implicitly defined by how it generates code and manifest entries, aligning with the <code>DeeplinkConfig</code> structure).</li> </ul> </li> <li> <p>Android Manifest Generation:</p> <ul> <li>Based on the parsed <code>deeplinkSpecs</code> from your YAML file, the plugin dynamically generates the necessary <code>&lt;intent-filter&gt;</code> entries within your app's <code>AndroidManifest.xml</code>.</li> <li>For each <code>DeeplinkConfig</code> entry in your YAML, it creates an <code>&lt;activity&gt;</code> (or merges with an existing one if the <code>activity</code> name matches) and adds an <code>&lt;intent-filter&gt;</code> to it.</li> <li>This automation means you do not need to manually write or maintain these <code>&lt;intent-filter&gt;</code> tags in your main <code>AndroidManifest.xml</code> for the deep links defined in your YAML. The plugin handles keeping them in sync with your YAML configuration.</li> <li>The generated manifest entries are typically merged into the final manifest during the build process (e.g., visible in <code>app/build/intermediates/merged_manifests/debug/AndroidManifest.xml</code>).</li> </ul> </li> <li> <p>Code Generation (<code>DeeplinkSpecs</code>):</p> <ul> <li>The plugin generates Kotlin source code, most notably a class named something like <code>[DeeplinkName]DeeplinkSpecs</code> (the exact name might vary based on the deeplink name in the <code>.yml</code> file).</li> <li>The plugin also generates params classes for deeplinks with typed path/query/fragment values.</li> <li>It additionally generates a module-level sealed interface (for example, module <code>app</code> -&gt; <code>AppDeeplinkParams</code>) implemented by all generated params classes, enabling exhaustive <code>when</code> matching in app code.</li> <li>It generates a module-level processor object (for example, module <code>app</code> -&gt; <code>AppDeeplinkProcessor</code>) wired with all generated specs so no manual registration is required.</li> </ul> </li> <li> <p>Integration with Build Process:</p> <ul> <li>The plugin hooks into the Android Gradle Plugin's build lifecycle.</li> <li>Its tasks (like YAML parsing, manifest generation, code generation) typically run before Java/Kotlin compilation, ensuring that the generated code and manifest entries are available when the rest of your app's code (including the codegen process) is processed.</li> </ul> </li> <li> <p>Configuration Options:</p> <ul> <li>The plugin provides a DSL (Domain Specific Language) extension in your <code>build.gradle</code> (<code>deepMatch { ... }</code> block) to customize its behavior:<ul> <li>generateManifestFiles: Specifying whether or not the plugin should generate <code>AndroidManifest.xml</code> file based on the deeplink config <code>yaml</code> file.</li> </ul> </li> </ul> </li> </ol>"},{"location":"gradle_plugin/#benefits-of-using-the-plugin","title":"Benefits of Using the Plugin","text":"<ul> <li>Single Source of Truth: Your <code>.deeplinks.yml</code> becomes the definitive source for all your deep link definitions.</li> <li>Reduced Boilerplate: No need to manually write complex and error-prone <code>&lt;intent-filter&gt;</code> tags in the manifest.</li> <li>Consistency: Ensures that your manifest and the runtime parsing logic are always in sync with your declared specifications.</li> <li>Improved Maintainability: Adding, removing, or modifying deep links is as simple as editing the YAML file and rebuilding.</li> <li>Build-Time Checks (Implicit): While not a full validation suite, the parsing step can catch basic syntax errors in your YAML file early in the build process.</li> </ul>"},{"location":"gradle_plugin/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Apply the plugin alongside your usual Android and Kotlin plugins:</p> <p><code>kotlin plugins {     id(\"com.android.application\")     id(\"org.jetbrains.kotlin.android\")     id(\"com.aouledissa.deepmatch.gradle\") version \"0.1.0\" }</code></p> </li> <li> <p>Configure the extension in the same module:</p> <p><code>kotlin deepMatch {     generateManifestFiles = true }</code></p> </li> <li> <p>Add a <code>.deeplinks.yml</code> file at the module root (or under <code>src/&lt;variant&gt;/.deeplinks.yml</code>). See <code>docs/config_file.md</code> for the full schema.</p> </li> </ol> <p>During the build the plugin generates Kotlin sources under <code>build/generated/</code> and, when enabled, a manifest snippet under <code>build/generated/manifests/&lt;variant&gt;/AndroidManifest.xml</code>.</p>"},{"location":"gradle_plugin/#generated-artifacts","title":"Generated Artifacts","text":"<ul> <li><code>&lt;ModuleName&gt;DeeplinkParams.kt</code> \u2014 module-level sealed interface implemented by generated params classes.</li> <li><code>&lt;ModuleName&gt;DeeplinkProcessor.kt</code> \u2014 module-level processor object extending <code>DeeplinkProcessor</code> and preconfigured with all generated specs.</li> <li><code>*DeeplinkSpecs.kt</code> \u2014 exposes a <code>DeeplinkSpec</code> property per configuration entry.</li> <li><code>*DeeplinkParams.kt</code> \u2014 optional data class emitted when a deeplink defines typed template, query, or fragment parameters.</li> <li>Generated manifest file \u2014 contains <code>&lt;intent-filter&gt;</code> definitions that Gradle merges into the final manifest.</li> </ul>"},{"location":"gradle_plugin/#available-tasks","title":"Available Tasks","text":"<p>Each Android variant gets two dedicated tasks:</p> <ul> <li><code>generate&lt;Variant&gt;DeeplinkSpecs</code> \u2014 parses YAML and produces Kotlin sources.</li> <li><code>generate&lt;Variant&gt;DeeplinksManifest</code> \u2014 writes the manifest file when <code>generateManifestFiles</code> is <code>true</code>.</li> </ul> <p>Inspect the generated output with:</p> <pre><code>./gradlew :app:generateDebugDeeplinkSpecs\n</code></pre>"},{"location":"gradle_plugin/#testing-ci","title":"Testing &amp; CI","text":"<pre><code>./gradlew publishToMavenLocal  # Optional; handy when consuming the plugin from another project locally\n./gradlew test                 # Runs JVM tests for the plugin, runtime, and shared fixtures\n</code></pre> <p>Runtime behaviour is validated with Robolectric-based tests in <code>deepmatch-processor/src/test</code>, backed by reusable fakes from the <code>deepmatch-testing</code> module. The GitHub Action workflow (<code>.github/workflows/ci.yml</code>) runs the same <code>test</code> task on every push and pull request; enable branch protection to require the CI workflow before merging.</p>"},{"location":"migration-guide-0.2.0-alpha/","title":"Migration Guide: 0.1.x to 0.2.0-alpha","text":"<p>This guide covers migration from the handler/builder runtime model to the generated processor + typed return model introduced in <code>0.2.0-alpha</code>.</p>"},{"location":"migration-guide-0.2.0-alpha/#what-changed","title":"What Changed","text":"<ul> <li><code>DeeplinkHandler</code> was removed.</li> <li><code>DeeplinkProcessor.Builder</code> was removed.</li> <li><code>DeeplinkProcessorImpl</code> was removed.</li> <li>Runtime flow is now:</li> <li>generate specs/params/processor from <code>.deeplinks.yml</code>,</li> <li>call generated <code>&lt;ModuleName&gt;DeeplinkProcessor.match(uri)</code>,</li> <li>handle typed params in caller code.</li> </ul>"},{"location":"migration-guide-0.2.0-alpha/#1-remove-builder-handler-wiring","title":"1. Remove Builder + Handler Wiring","text":"<p>Before:</p> <pre><code>val processor = DeeplinkProcessor.Builder()\n    .register(OpenSeriesDeeplinkSpecs /*, handler */)\n    .build()\n</code></pre> <p>After:</p> <pre><code>// Generated by DeepMatch plugin\n// Example for module \"app\": AppDeeplinkProcessor\n</code></pre> <p>Use the generated object directly:</p> <pre><code>val params = AppDeeplinkProcessor.match(uri)\n</code></pre>"},{"location":"migration-guide-0.2.0-alpha/#2-move-handling-logic-to-the-caller","title":"2. Move Handling Logic to the Caller","text":"<p>Before, deeplink side effects were handler-based. After, do caller-side branching:</p> <pre><code>when (val params = AppDeeplinkProcessor.match(uri) as? AppDeeplinkParams) {\n    is OpenSeriesDeeplinkParams -&gt; {\n        // navigate to series\n    }\n    is OpenProfileDeeplinkParams -&gt; {\n        // navigate to profile\n    }\n    null -&gt; {\n        // no deeplink match\n    }\n}\n</code></pre>"},{"location":"migration-guide-0.2.0-alpha/#3-use-generated-sealed-params-for-exhaustive-branching","title":"3. Use Generated Sealed Params for Exhaustive Branching","text":"<p>The plugin generates a sealed interface named from your module:</p> <ul> <li>module <code>app</code> -&gt; <code>AppDeeplinkParams</code></li> <li>module <code>feature-media</code> -&gt; <code>FeatureMediaDeeplinkParams</code></li> </ul> <p>All generated params classes implement this interface, enabling exhaustive <code>when</code> checks.</p>"},{"location":"migration-guide-0.2.0-alpha/#4-testing-updates","title":"4. Testing Updates","text":"<ul> <li>Remove tests focused on builder registration and handler dispatch.</li> <li>Add assertions around <code>match(uri)</code> return values and typed params extraction.</li> <li>Use a fake processor that stubs <code>match</code> via a <code>configure { ... }</code> lambda when needed.</li> </ul>"},{"location":"migration-guide-0.2.0-alpha/#5-optional-validate-with-sample-app","title":"5. Optional: Validate with Sample App","text":"<p>See <code>samples/android-app/README.md</code> for:</p> <ul> <li>composite-build local plugin resolution,</li> <li>generated manifest validation,</li> <li>real deeplink smoke tests via <code>adb</code>.</li> </ul>"},{"location":"release-notes/0.1.0-alpha/","title":"DeepMatch 0.1.0-alpha","text":"<ul> <li>Introduced the DeepMatch Gradle plugin (<code>com.aouledissa.deepmatch.gradle</code>) to parse   <code>.deeplinks.yml</code> specs per variant, generate Kotlin sources, and optionally emit Android manifest   entries.</li> <li>Added the DeepMatch Processor runtime library capable of matching URIs, building typed   parameter objects, and dispatching to strongly typed handlers.</li> <li>Published the shared DeepMatch API module containing the spec/parameter data models used   across plugin and runtime.</li> <li>Delivered a reusable DeepMatch Testing module with fake handlers/processors and spec fixtures   for unit test support.</li> </ul>"},{"location":"release-notes/0.2.0-alpha/","title":"DeepMatch 0.2.0-alpha","text":"<p>Release date: 2026-02-25</p>"},{"location":"release-notes/0.2.0-alpha/#highlights","title":"Highlights","text":"<ul> <li>Introduced a zero-configuration runtime flow driven by generated code:</li> <li>The plugin now generates a module processor object (for example, <code>AppDeeplinkProcessor</code>).</li> <li>Clients can call <code>match(uri)</code> directly and branch on typed params.</li> <li>Added module-level sealed params generation (for example, <code>AppDeeplinkParams</code>), with generated   <code>*DeeplinkParams</code> implementing this sealed interface for exhaustive <code>when</code> checks.</li> <li>Added a composite-build sample app at <code>samples/android-app</code> demonstrating:</li> <li>generated processor usage in Compose UI,</li> <li>generated manifest deeplink filters,</li> <li>real-device deeplink validation with <code>adb</code>.</li> </ul>"},{"location":"release-notes/0.2.0-alpha/#breaking-changes","title":"Breaking Changes","text":"<ul> <li><code>DeeplinkProcessor</code> moved from interface-based builder wiring to an open class configured with specs.</li> <li>Removed:</li> <li><code>DeeplinkHandler</code></li> <li><code>DeeplinkProcessor.Builder</code></li> <li><code>DeeplinkProcessorImpl</code></li> <li>Runtime matching is now return-based:</li> <li><code>match(uri: Uri): DeeplinkParams?</code></li> </ul>"},{"location":"release-notes/0.2.0-alpha/#migration-summary","title":"Migration Summary","text":"<ul> <li>Replace builder setup with the generated module processor object.</li> <li>Move deeplink handling logic to caller-side <code>when</code> branching.</li> <li>See the full Migration Guide.</li> </ul>"}]}