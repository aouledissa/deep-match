{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"config_file/","title":"YAML Spec","text":""},{"location":"config_file/#deeplink-configuration-object-deeplinkconfig","title":"Deeplink Configuration Object (<code>DeeplinkConfig</code>)","text":"<p>Each item in the <code>deeplinkSpecs</code> list is a deep link configuration object with the following properties, corresponding to the fields in your <code>DeeplinkConfig</code> Kotlin class:</p> <ul> <li> <p><code>name</code>: (Required, String)</p> <ul> <li>A unique identifier for this deep link specification. This name will be used to link to specific handlers in your code.</li> <li>Example: <code>userProfile</code>, <code>productView</code></li> </ul> </li> <li> <p><code>activity</code>: (Required, String)</p> <ul> <li>The fully qualified name of the Android Activity that will be primarily associated with this deep link in the <code>AndroidManifest.xml</code>.</li> <li>Example: <code>com.example.myapp.MainActivity</code>, <code>com.example.myapp.ProductDetailsActivity</code></li> </ul> </li> <li> <p><code>categories</code>: (Optional, List of Strings, defaults to <code>[\"DEFAULT\"]</code>)</p> <ul> <li>A list of intent filter categories to be added to the generated <code>&lt;intent-filter&gt;</code> in the <code>AndroidManifest.xml</code>.</li> <li>Valid values correspond to <code>IntentFilterCategory</code> enum (e.g., <code>DEFAULT</code>, <code>BROWSABLE</code>). The YAML value should be the string representation of the enum constant.</li> <li>Example: <code>categories: [DEFAULT, BROWSABLE]</code></li> <li>If omitted, it defaults to <code>[DEFAULT]</code>.</li> </ul> </li> <li> <p><code>autoVerify</code>: (Optional, Boolean, defaults to <code>false</code>)</p> <ul> <li>If set to <code>true</code>, the <code>android:autoVerify=\"true\"</code> attribute will be added to the generated <code>&lt;intent-filter&gt;</code>. This is necessary for Android App Links.</li> <li>Example: <code>autoVerify: true</code></li> </ul> </li> <li> <p><code>scheme</code>: (Required, List of Strings)</p> <ul> <li>One or more URI schemes supported by the deeplink.</li> <li>Example: <code>scheme: [myapp, https]</code></li> </ul> </li> <li> <p><code>host</code>: (Required, List of Strings)</p> <ul> <li>One or more hosts (domains) that should resolve to this deeplink.</li> <li>Example: <code>host: [\"example.com\", \"m.example.com\"]</code></li> </ul> </li> <li> <p><code>pathParams</code>: (Optional, List of Param objects)</p> <ul> <li>Defines ordered parameters that are part of the URI path. Each item in the list is a <code>Param</code> object.</li> <li>Param Object Structure:<ul> <li><code>name</code>: (Required, String) The name of the path parameter (e.g., <code>userId</code>, <code>itemId</code>). This is how you'll refer to it in your handler.</li> <li><code>type</code>: (Optional, String) The expected data type of the parameter. When provided, the generated matcher validates the segment against the type\u2019s regex and the runtime converts the value to the corresponding Kotlin type.</li> </ul> </li> <li>Example:     ```yaml     pathParams:<ul> <li>name: user</li> <li>name: userId     type: alphanumeric ```</li> </ul> </li> </ul> </li> <li> <p><code>queryParams</code>: (Optional, List of Param objects)</p> <ul> <li>Mirrors the structure of <code>pathParams</code> but for query string parameters.</li> <li>Query params should declare a <code>type</code> so the generated regex and parameter class enforce the expected format and type conversion.</li> <li>Example:     ```yaml     queryParams:<ul> <li>name: ref     type: string</li> <li>name: page     type: numeric ```</li> </ul> </li> </ul> </li> <li> <p><code>fragment</code>: (Optional, String)</p> <ul> <li>Adds a fragment requirement (<code>#details</code>). When provided, the generated parameter class exposes it as a property.</li> </ul> </li> <li> <p><code>description</code>: (Optional, String)</p> <ul> <li>Free-form text to describe the deeplink\u2019s purpose. Currently informational only.</li> </ul> </li> </ul>"},{"location":"config_file/#complete-example","title":"Complete Example","text":"<pre><code>deeplinkSpecs:\n  - name: \"open profile\"\n    description: \"Navigate to a user profile page\"\n    activity: com.example.app.MainActivity\n    autoVerify: true\n    categories: [DEFAULT, BROWSABLE]\n    scheme: [https, app]\n    host: [\"example.com\"]\n    pathParams:\n      - name: users\n      - name: userId\n        type: alphanumeric\n    queryParams:\n      - name: ref\n        type: string\n    fragment: \"details\"\n</code></pre>"},{"location":"config_file/#tips","title":"Tips","text":"<ul> <li>Keep <code>name</code> values unique per spec to simplify handler identification.</li> <li>Regenerate sources (<code>./gradlew generate&lt;Variant&gt;DeeplinkSpecs</code>) whenever you modify the YAML schema.</li> <li>If <code>generateManifestFiles</code> is disabled, remember to replicate the <code>&lt;intent-filter&gt;</code> changes manually in your main manifest.</li> <li>When a deeplink declares typed path, query, or fragment values, the plugin also creates a <code>&lt;Name&gt;DeeplinkParams</code> class so your handler receives strongly typed arguments.</li> </ul>"},{"location":"gradle_plugin/","title":"Gradle Plugin","text":""},{"location":"gradle_plugin/#core-capabilities","title":"Core Capabilities","text":"<p>The primary responsibilities and capabilities of the DeepMatch Gradle plugin are:</p> <ol> <li> <p>YAML Configuration Parsing:</p> <ul> <li>The plugin automatically locates and reads your <code>.deeplinks.yml</code> file (by default, from the root of the module, e.g., <code>app/.deeplinks.yml</code>, but this is configurable).</li> <li>It parses the YAML content, validating its structure against the expected format (implicitly defined by how it generates code and manifest entries, aligning with the <code>DeeplinkConfig</code> structure).</li> </ul> </li> <li> <p>Android Manifest Generation:</p> <ul> <li>Based on the parsed <code>deeplinkSpecs</code> from your YAML file, the plugin dynamically generates the necessary <code>&lt;intent-filter&gt;</code> entries within your app's <code>AndroidManifest.xml</code>.</li> <li>For each <code>DeeplinkConfig</code> entry in your YAML, it creates an <code>&lt;activity&gt;</code> (or merges with an existing one if the <code>activity</code> name matches) and adds an <code>&lt;intent-filter&gt;</code> to it.</li> <li>This automation means you do not need to manually write or maintain these <code>&lt;intent-filter&gt;</code> tags in your main <code>AndroidManifest.xml</code> for the deep links defined in your YAML. The plugin handles keeping them in sync with your YAML configuration.</li> <li>The generated manifest entries are typically merged into the final manifest during the build process (e.g., visible in <code>app/build/intermediates/merged_manifests/debug/AndroidManifest.xml</code>).</li> </ul> </li> <li> <p>Code Generation (<code>DeeplinkSpecs</code>):</p> <ul> <li>The plugin generates Kotlin source code, most notably a class named something like <code>[DeeplinkName]DeeplinkSpecs</code> (the exact name might vary based on the deeplink name in the <code>.yml</code> file).</li> <li>The plugin also generates another Kotlin source for the dynamic params in the configured deeplink. This means if any of your deeplink's path parameters is pattern-based or if the deeplink contains at least one query parameter, a parameter class will be generated.</li> <li>This makes it easy to access these parameters later when matching and handling the deeplink. </li> </ul> </li> <li> <p>Integration with Build Process:</p> <ul> <li>The plugin hooks into the Android Gradle Plugin's build lifecycle.</li> <li>Its tasks (like YAML parsing, manifest generation, code generation) typically run before Java/Kotlin compilation, ensuring that the generated code and manifest entries are available when the rest of your app's code (including the codegen process) is processed.</li> </ul> </li> <li> <p>Configuration Options:</p> <ul> <li>The plugin provides a DSL (Domain Specific Language) extension in your <code>build.gradle</code> (<code>deepMatch { ... }</code> block) to customize its behavior:<ul> <li>specsFile: Specifying a custom path to your <code>.deeplinks.yml</code> file if it's not in the default location.</li> <li>generateManifestFiles: Specifying whether or not the plugin should generate <code>AndroidManifest.xml</code> file based on the deeplink config <code>yaml</code> file.</li> </ul> </li> </ul> </li> </ol>"},{"location":"gradle_plugin/#benefits-of-using-the-plugin","title":"Benefits of Using the Plugin","text":"<ul> <li>Single Source of Truth: Your <code>.deeplinks.yml</code> becomes the definitive source for all your deep link definitions.</li> <li>Reduced Boilerplate: No need to manually write complex and error-prone <code>&lt;intent-filter&gt;</code> tags in the manifest.</li> <li>Consistency: Ensures that your manifest and the runtime parsing logic are always in sync with your declared specifications.</li> <li>Improved Maintainability: Adding, removing, or modifying deep links is as simple as editing the YAML file and rebuilding.</li> <li>Build-Time Checks (Implicit): While not a full validation suite, the parsing step can catch basic syntax errors in your YAML file early in the build process.</li> </ul>"},{"location":"gradle_plugin/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Apply the plugin alongside your usual Android and Kotlin plugins:</p> <p><code>kotlin plugins {     id(\"com.android.application\")     id(\"org.jetbrains.kotlin.android\")     id(\"com.aouledissa.deepmatch.gradle\") version \"0.1.0\" }</code></p> </li> <li> <p>Configure the extension in the same module:</p> <p><code>kotlin deepMatch {     generateManifestFiles = true }</code></p> </li> <li> <p>Add a <code>.deeplinks.yml</code> file at the module root (or under <code>src/&lt;variant&gt;/.deeplinks.yml</code>). See <code>docs/config_file.md</code> for the full schema.</p> </li> </ol> <p>During the build the plugin generates Kotlin sources under <code>build/generated/</code> and, when enabled, a manifest snippet under <code>build/generated/manifests/&lt;variant&gt;/AndroidManifest.xml</code>.</p>"},{"location":"gradle_plugin/#generated-artifacts","title":"Generated Artifacts","text":"<ul> <li><code>*DeeplinkSpecs.kt</code> \u2014 exposes a <code>DeeplinkSpec</code> property per configuration entry.</li> <li><code>*DeeplinkParams.kt</code> \u2014 optional data class emitted when a deeplink defines typed template, query, or fragment parameters.</li> <li>Generated manifest file \u2014 contains <code>&lt;intent-filter&gt;</code> definitions that Gradle merges into the final manifest.</li> </ul>"},{"location":"gradle_plugin/#available-tasks","title":"Available Tasks","text":"<p>Each Android variant gets two dedicated tasks:</p> <ul> <li><code>generate&lt;Variant&gt;DeeplinkSpecs</code> \u2014 parses YAML and produces Kotlin sources.</li> <li><code>generate&lt;Variant&gt;DeeplinksManifest</code> \u2014 writes the manifest file when <code>generateManifestFiles</code> is <code>true</code>.</li> </ul> <p>Inspect the generated output with:</p> <pre><code>./gradlew :app:generateDebugDeeplinkSpecs\n</code></pre>"},{"location":"gradle_plugin/#testing-ci","title":"Testing &amp; CI","text":"<pre><code>./gradlew publishToMavenLocal  # Optional; handy when consuming the plugin from another project locally\n./gradlew test                 # Runs JVM tests for the plugin, runtime, and shared fixtures\n</code></pre> <p>Runtime behaviour is validated with Robolectric-based tests in <code>deepmatch-processor/src/test</code>, backed by reusable fakes from the <code>deepmatch-testing</code> module. The GitHub Action workflow (<code>.github/workflows/ci.yml</code>) runs the same <code>test</code> task on every push and pull request; enable branch protection to require the CI workflow before merging.</p>"}]}