{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"DeepMatch","text":"<p>DeepMatch keeps your Android deeplinks consistent from configuration to runtime. The Gradle plugin parses deeplink YAML spec files and generates Kotlin sources plus optional manifest entries, while the runtime library matches incoming URIs and returns strongly-typed params.</p>","path":["DeepMatch"],"tags":[]},{"location":"#key-components","level":2,"title":"Key Components","text":"<ul> <li>deepmatch-plugin — Gradle plugin you apply to Android modules to parse specs and generate code.</li> <li>deepmatch-processor — Runtime matcher that maps URIs to specs and builds parameter objects.</li> <li>deepmatch-api — Shared spec/parameter data models used across plugin and runtime.</li> <li>deepmatch-testing — Reusable fixtures that assist in unit testing DeepMatch integrations.</li> </ul>","path":["DeepMatch"],"tags":[]},{"location":"#getting-started","level":2,"title":"Getting Started","text":"<ol> <li>Add the plugin to your Android module:</li> </ol> <pre><code>plugins {\n    id(\"com.android.application\")\n    id(\"org.jetbrains.kotlin.android\")\n    id(\"com.aouledissa.deepmatch.gradle\") version \"&lt;DEEPMATCH_VERSION&gt;\"\n}\n</code></pre> <ol> <li>Add the runtime dependency:</li> </ol> <pre><code>dependencies {\n    implementation(\"com.aouledissa.deepmatch:deepmatch-processor:&lt;DEEPMATCH_VERSION&gt;\")\n}\n</code></pre> <ol> <li>Configure DeepMatch:</li> </ol> <pre><code>deepMatch {\n    generateManifestFiles = true\n}\n</code></pre> <p>By default, DeepMatch auto-composes processors from project dependencies that also apply the plugin.</p> <ol> <li>Create one or more spec files in your module:</li> <li>Module root: <code>.deeplinks.yml</code> or <code>*.deeplinks.yml</code></li> <li>Variant folder: <code>src/&lt;variant&gt;/.deeplinks.yml</code> or <code>src/&lt;variant&gt;/*.deeplinks.yml</code></li> <li>Merge precedence is root first, then variant. Same-name specs in later sources override earlier ones.</li> </ol> <pre><code>deeplinkSpecs:\n  - name: \"open series\"\n    activity: com.example.app.MainActivity\n    categories: [DEFAULT, BROWSABLE]\n    scheme: [https, app]\n    host: [\"example.com\"]\n    pathParams:\n      - name: series\n      - name: seriesId\n        type: numeric\n    queryParams:\n      - name: query\n        type: string\n        required: true\n      - name: ref\n        type: string\n</code></pre> <p>Typed query params are validated by key and type, so query ordering does not matter. For example, <code>?ref=promo&amp;page=1</code> and <code>?page=1&amp;ref=promo</code> are treated the same. Query params are optional by default; use <code>required: true</code> for mandatory keys. Path params are ordered and matched by position as declared in YAML. If <code>port</code> is declared, it is matched at runtime and emitted in generated manifest filters.</p> <ol> <li>Generate sources (or run a normal build):</li> </ol> <pre><code>./gradlew :app:generateDebugDeeplinkSpecs\n</code></pre> <p>Need task details or URI validation? See Tasks. Need a human-friendly catalog and browser validator (full catalog + source/module views)? See Report. The report validates URIs against your specs in-browser, so no app run is required.</p> <ol> <li>Use the generated processor:</li> </ol> <pre><code>intent.data?.let { uri -&gt;\n    when (val params = AppDeeplinkProcessor.match(uri) as? AppDeeplinkParams) {\n        is OpenSeriesDeeplinkParams -&gt; {\n            // use parsed params\n        }\n        null -&gt; {\n            // no match\n        }\n    }\n}\n</code></pre> <p>Runtime APIs are also available when you want custom wiring:</p> <ul> <li> <p><code>CompositeDeeplinkProcessor</code> to chain processors and return the first match.</p> </li> <li> <p>Optional device test with ADB:</p> </li> </ul> <pre><code>adb shell am start -W \\\n  -a android.intent.action.VIEW \\\n  -c android.intent.category.BROWSABLE \\\n  -d \"app://example.com/series/42?ref=promo\"\n</code></pre> <p>For an end-to-end sample app flow, see the repository sample at <code>samples/android-app/README.md</code>. For schema/plugin details, see Deeplink Specs, Plugin, and Composite Specs.</p>","path":["DeepMatch"],"tags":[]},{"location":"#upgrading","level":2,"title":"Upgrading","text":"<ul> <li>Check Release Notes for version-specific changes.</li> <li>For multi-file specs/report/override precedence in <code>0.3.0-beta</code>, follow Migration Guide.</li> <li>For the runtime refactor in <code>0.2.0-alpha</code>, follow Migration Guide.</li> </ul>","path":["DeepMatch"],"tags":[]},{"location":"#building-the-documentation","level":2,"title":"Building the Documentation","text":"<pre><code>pip install -r docs/requirements.txt  # once\nzensical serve                          # start live-reloading docs site\n</code></pre> <p>The documentation is built with Zensical.</p>","path":["DeepMatch"],"tags":[]},{"location":"composite-specs/","level":1,"title":"Composite Specs","text":"<p>DeepMatch supports both:</p> <ul> <li>Multiple deeplink specs in one module.</li> <li>Multiple Android modules, each with its own DeepMatch-generated processor.</li> </ul>","path":["Composite Specs"],"tags":[]},{"location":"composite-specs/#how-to-structure-specs","level":2,"title":"How to Structure Specs","text":"<p>Each module can define:</p> <ul> <li>Module root sources: <code>.deeplinks.yml</code> and <code>*.deeplinks.yml</code></li> <li>Variant sources: <code>src/&lt;variant&gt;/.deeplinks.yml</code> and <code>src/&lt;variant&gt;/*.deeplinks.yml</code></li> </ul> <p>Discovery and merge rules:</p> <ol> <li>Root files are loaded first (sorted by file name).</li> <li>Variant files are loaded next (sorted by file name).</li> <li>If two sources define the same spec <code>name</code>, the later source overrides the earlier one.</li> </ol>","path":["Composite Specs"],"tags":[]},{"location":"composite-specs/#multi-module-setup","level":2,"title":"Multi-Module Setup","text":"<p>Example project:</p> <pre><code>:app\n:feature-profile\n:feature-series\n</code></pre> <p>Apply the plugin in each participating module:</p> <pre><code>plugins {\n    id(\"com.android.library\") // or com.android.application\n    id(\"org.jetbrains.kotlin.android\")\n    id(\"com.aouledissa.deepmatch.gradle\")\n}\n</code></pre> <p>If <code>:app</code> depends on <code>:feature-profile</code> and <code>:feature-series</code>, the app's generated processor automatically composes their generated processors.</p> <p>No extra plugin configuration is required.</p>","path":["Composite Specs"],"tags":[]},{"location":"composite-specs/#what-gets-generated","level":2,"title":"What Gets Generated","text":"<p>For each module:</p> <ul> <li><code>&lt;ModuleName&gt;DeeplinkParams</code> (sealed interface)</li> <li><code>&lt;ModuleName&gt;DeeplinkProcessor</code> (generated processor object)</li> <li>One <code>*DeeplinkSpecs</code> + one <code>*DeeplinkParams</code> per spec</li> </ul> <p>For app modules with DeepMatch-enabled dependencies, <code>&lt;ModuleName&gt;DeeplinkProcessor</code> is generated as a <code>CompositeDeeplinkProcessor</code>.</p>","path":["Composite Specs"],"tags":[]},{"location":"composite-specs/#resolution-order","level":2,"title":"Resolution Order","text":"<p>When you call:</p> <pre><code>val result = AppDeeplinkProcessor.match(uri)\n</code></pre> <p>DeepMatch resolves in this order:</p> <ol> <li>Local module specs are evaluated first.</li> <li>Local specs come from merged discovered files (root first, then variant with override-by-name).</li> <li>If local specs do not match, composed dependency processors are tried (deterministic order).</li> <li>The first non-null match wins.</li> <li>If nothing matches, result is <code>null</code>.</li> </ol>","path":["Composite Specs"],"tags":[]},{"location":"composite-specs/#practical-implication","level":3,"title":"Practical Implication","text":"<p>If two modules can match the same URI shape, precedence is determined by composition order. Dependency processors are composed in deterministic FQCN order. Keep specs unique across modules whenever possible to avoid ambiguous ownership.</p>","path":["Composite Specs"],"tags":[]},{"location":"composite-specs/#example","level":2,"title":"Example","text":"<pre><code>when (val params = AppDeeplinkProcessor.match(uri)) {\n    is OpenProfileDeeplinkParams -&gt; { /* app module flow */ }\n    is com.example.feature.profile.deeplinks.OpenFeatureProfileDeeplinkParams -&gt; { /* feature flow */ }\n    null -&gt; { /* no match */ }\n}\n</code></pre> <p>In composed mode, result type is <code>DeeplinkParams?</code> and can come from dependent modules too. Use concrete generated params types from each participating module, or call module processors directly when you want module-local exhaustive <code>when</code>.</p>","path":["Composite Specs"],"tags":[]},{"location":"composite-specs/#collision-validation","level":2,"title":"Collision Validation","text":"<p>DeepMatch also validates composed URI-shape collisions per variant.</p> <ul> <li>Task name: <code>validate&lt;Variant&gt;CompositeSpecsCollisions</code> (for example, <code>validateDebugCompositeSpecsCollisions</code>).</li> <li>It compares normalized spec shapes across app + composed dependency modules.</li> <li>If two modules declare the same shape, build fails with a detailed collision report.</li> </ul> <p>This protects multi-module projects from accidental first-match routing conflicts.</p>","path":["Composite Specs"],"tags":[]},{"location":"deeplink-specs/","level":1,"title":"Deeplink specs","text":"","path":["Deeplink specs"],"tags":[]},{"location":"deeplink-specs/#deeplink-configuration-object-deeplinkconfig","level":3,"title":"Deeplink Configuration Object (<code>DeeplinkConfig</code>)","text":"<p>Each item in the deeplinkSpecs list is a deep link configuration object with the following properties:</p> <ul> <li> <p><code>name</code></p> <ul> <li>Type: String</li> <li>Required: Yes</li> <li>Description: Unique identifier for the deeplink spec. Used for generated names and must be unique across all specs in the file.</li> <li>Example:   <pre><code>name: \"open profile\"\n</code></pre></li> </ul> </li> <li> <p><code>activity</code></p> <ul> <li>Type: String</li> <li>Required: Yes</li> <li>Description: Fully qualified name of the activity eligible to resolve this deeplink.</li> <li>Example:   <pre><code>activity: com.example.app.MainActivity\n</code></pre></li> </ul> </li> <li> <p><code>categories</code></p> <ul> <li>Type: List <li>Required: No (default: [DEFAULT])</li> <li>Description: Intent filter categories (DEFAULT, BROWSABLE, etc.).</li> <li>Example:   <pre><code>categories: [DEFAULT, BROWSABLE]\n</code></pre></li> <li> <p><code>autoVerify</code></p> <ul> <li>Type: Boolean</li> <li>Required: No (default: false)</li> <li>Description: Enables android:autoVerify=\"true\" for app links.</li> <li>Example:   <pre><code>autoVerify: true\n</code></pre></li> </ul> </li> <li> <p><code>scheme</code></p> <ul> <li>Type: List <li>Required: Yes</li> <li>Description: Allowed URI schemes.</li> <li>Example:   <pre><code>scheme: [app, https]\n</code></pre></li> <li> <p><code>host</code></p> <ul> <li>Type: List <li>Required: No (default: [])</li> <li>Description: Allowed URI hosts/domains. Leave empty (or omit) for hostless URIs such as app:///profile/123.</li> <li>Example:   <pre><code>host: [\"example.com\", \"m.example.com\"]\n</code></pre></li> <li> <p><code>port</code></p> <ul> <li>Type: Integer</li> <li>Required: No</li> <li>Description: Optional URI port filter (for example staging links on <code>:8080</code>).</li> <li>Example:   <pre><code>port: 8080\n</code></pre></li> </ul> </li> <li> <p><code>pathParams</code></p> <ul> <li>Type: List of Param</li> <li>Required: No</li> <li>Description: Ordered path segments/templates. Order is positional and preserved.</li> <li>Example:   <pre><code>pathParams:\n  - name: profile\n  - name: userId\n    type: alphanumeric\n</code></pre></li> </ul> </li> <li> <p><code>pathParams[].name</code></p> <ul> <li>Type: String</li> <li>Required: Yes (per item)</li> <li>Description: Path segment label or typed placeholder key.</li> <li>Example:   <pre><code>- name: userId\n</code></pre></li> </ul> </li> <li> <p><code>pathParams[].type</code></p> <ul> <li>Type: String</li> <li>Required: No</li> <li>Description: Path param value type (numeric, alphanumeric, string).</li> <li>Example:   <pre><code>- name: userId\n  type: numeric\n</code></pre></li> </ul> </li> <li> <p><code>queryParams</code></p> <ul> <li>Type: List of Param</li> <li>Required: No</li> <li>Description: Typed query definitions. Matching is order-agnostic.</li> <li>Example:   <pre><code>queryParams:\n  - name: query\n    type: string\n    required: true\n  - name: ref\n    type: string\n</code></pre></li> </ul> </li> <li> <p><code>queryParams[].name</code></p> <ul> <li>Type: String</li> <li>Required: Yes (per item)</li> <li>Description: Query key name.</li> <li>Example:   <pre><code>- name: page\n</code></pre></li> </ul> </li> <li> <p><code>queryParams[].type</code></p> <ul> <li>Type: String</li> <li>Required: Recommended</li> <li>Description: Query value type used for runtime validation and typed generation.</li> <li>Example:   <pre><code>- name: ref\n  type: string\n</code></pre></li> </ul> </li> <li> <p><code>queryParams[].required</code></p> <ul> <li>Type: Boolean</li> <li>Required: No (default: false)</li> <li>Description: If true, key must be present to match. Optional typed query params are generated nullable.</li> <li>Example:   <pre><code>- name: query\n  type: string\n  required: true\n</code></pre></li> </ul> </li> <li> <p><code>fragment</code></p> <ul> <li>Type: String</li> <li>Required: No</li> <li>Description: Required URI fragment (#...). Exposed in generated params when declared. Fragment matching is runtime-only (not manifest-level).</li> <li>Example:   <pre><code>fragment: \"details\"\n</code></pre></li> </ul> </li> <li> <p><code>description</code></p> <ul> <li>Type: String</li> <li>Required: No</li> <li>Description: Free-form description for the deeplink spec.</li> <li>Example:   <pre><code>description: \"Navigate to profile screen from campaign links\"\n</code></pre></li> </ul> </li>","path":["Deeplink specs"],"tags":[]},{"location":"deeplink-specs/#complete-example","level":3,"title":"Complete Example","text":"<pre><code>deeplinkSpecs:\n  - name: \"open profile\"\n    description: \"Navigate to a user profile page\"\n    activity: com.example.app.MainActivity\n    autoVerify: true\n    categories: [DEFAULT, BROWSABLE]\n    scheme: [https, app]\n    host: [\"example.com\"]\n    port: 8080\n    pathParams:\n      - name: users\n      - name: userId\n        type: alphanumeric\n    queryParams:\n      - name: query\n        type: string\n        required: true\n      - name: ref\n        type: string\n    fragment: \"details\"\n</code></pre>","path":["Deeplink specs"],"tags":[]},{"location":"deeplink-specs/#tips","level":3,"title":"Tips","text":"<ul> <li><code>name</code> values must be unique within each YAML source file. Across multiple sources, later files override earlier specs with the same <code>name</code>.</li> <li>Regenerate sources (<code>./gradlew generate&lt;Variant&gt;DeeplinkSpecs</code>) whenever you modify the YAML schema.</li> <li>If <code>generateManifestFiles</code> is disabled, remember to replicate the <code>&lt;intent-filter&gt;</code> changes manually in your main manifest.</li> <li>The plugin creates a <code>&lt;Name&gt;DeeplinkParams</code> class for every deeplink spec. This avoids ambiguity between \"no match\" and \"matched static deeplink\".</li> <li>Typed query params are validated by key and type after structural URI matching, so query order does not affect matching.</li> <li>Query params are optional by default; set <code>required: true</code> only for values that must be present.</li> <li>Scheme and host matching are case-insensitive, so values like <code>HTTPS://Example.COM/...</code> still match <code>scheme: [https]</code> and <code>host: [\"example.com\"]</code>.</li> <li><code>scheme</code> must contain at least one value. <code>host</code> can be omitted (or set to <code>[]</code>) for hostless URIs.</li> <li>Manifest generation does not filter by query params or fragment; those are validated by the runtime processor.</li> <li>All generated params classes implement a module-level sealed interface named from the module name (for example, module <code>app</code> -&gt; <code>AppDeeplinkParams</code>), enabling exhaustive <code>when</code> checks.</li> <li>The plugin also generates a module-level processor object named from the module name (for example, module <code>app</code> -&gt; <code>AppDeeplinkProcessor</code>) preloaded with all generated specs.</li> </ul>","path":["Deeplink specs"],"tags":[]},{"location":"migration-guide-0.2.0-alpha/","level":1,"title":"Migration Guide: 0.1.x to 0.2.0-alpha","text":"<p>This guide covers migration from the handler/builder runtime model to the generated processor + typed return model introduced in <code>0.2.0-alpha</code>.</p>","path":["Migration Guides","Migration Guide: 0.1.x to 0.2.0-alpha"],"tags":[]},{"location":"migration-guide-0.2.0-alpha/#what-changed","level":2,"title":"What Changed","text":"<ul> <li><code>DeeplinkHandler</code> was removed.</li> <li><code>DeeplinkProcessor.Builder</code> was removed.</li> <li><code>DeeplinkProcessorImpl</code> was removed.</li> <li>Runtime flow is now:</li> <li>generate specs/params/processor from <code>.deeplinks.yml</code>,</li> <li>call generated <code>&lt;ModuleName&gt;DeeplinkProcessor.match(uri)</code>,</li> <li>handle typed params in caller code.</li> </ul>","path":["Migration Guides","Migration Guide: 0.1.x to 0.2.0-alpha"],"tags":[]},{"location":"migration-guide-0.2.0-alpha/#1-remove-builder-handler-wiring","level":2,"title":"1. Remove Builder + Handler Wiring","text":"<p>Before:</p> <pre><code>val processor = DeeplinkProcessor.Builder()\n    .register(OpenSeriesDeeplinkSpecs /*, handler */)\n    .build()\n</code></pre> <p>After:</p> <pre><code>// Generated by DeepMatch plugin\n// Example for module \"app\": AppDeeplinkProcessor\n</code></pre> <p>Use the generated object directly:</p> <pre><code>val params = AppDeeplinkProcessor.match(uri)\n</code></pre>","path":["Migration Guides","Migration Guide: 0.1.x to 0.2.0-alpha"],"tags":[]},{"location":"migration-guide-0.2.0-alpha/#2-move-handling-logic-to-the-caller","level":2,"title":"2. Move Handling Logic to the Caller","text":"<p>Before, deeplink side effects were handler-based. After, do caller-side branching:</p> <pre><code>when (val params = AppDeeplinkProcessor.match(uri) as? AppDeeplinkParams) {\n    is OpenSeriesDeeplinkParams -&gt; {\n        // navigate to series\n    }\n    is OpenProfileDeeplinkParams -&gt; {\n        // navigate to profile\n    }\n    null -&gt; {\n        // no deeplink match\n    }\n}\n</code></pre>","path":["Migration Guides","Migration Guide: 0.1.x to 0.2.0-alpha"],"tags":[]},{"location":"migration-guide-0.2.0-alpha/#3-use-generated-sealed-params-for-exhaustive-branching","level":2,"title":"3. Use Generated Sealed Params for Exhaustive Branching","text":"<p>The plugin generates a sealed interface named from your module:</p> <ul> <li>module <code>app</code> -&gt; <code>AppDeeplinkParams</code></li> <li>module <code>feature-media</code> -&gt; <code>FeatureMediaDeeplinkParams</code></li> </ul> <p>All generated params classes implement this interface, enabling exhaustive <code>when</code> checks.</p>","path":["Migration Guides","Migration Guide: 0.1.x to 0.2.0-alpha"],"tags":[]},{"location":"migration-guide-0.2.0-alpha/#4-testing-updates","level":2,"title":"4. Testing Updates","text":"<ul> <li>Remove tests focused on builder registration and handler dispatch.</li> <li>Add assertions around <code>match(uri)</code> return values and typed params extraction.</li> <li>Use a fake processor that stubs <code>match</code> via a <code>configure { ... }</code> lambda when needed.</li> </ul>","path":["Migration Guides","Migration Guide: 0.1.x to 0.2.0-alpha"],"tags":[]},{"location":"migration-guide-0.2.0-alpha/#5-optional-validate-with-sample-app","level":2,"title":"5. Optional: Validate with Sample App","text":"<p>See <code>samples/android-app/README.md</code> for:</p> <ul> <li>composite-build local plugin resolution,</li> <li>generated manifest validation,</li> <li>real deeplink smoke tests via <code>adb</code>.</li> </ul>","path":["Migration Guides","Migration Guide: 0.1.x to 0.2.0-alpha"],"tags":[]},{"location":"migration-guide-0.3.0-beta/","level":1,"title":"Migration Guide: 0.2.0-alpha to 0.3.0-beta","text":"<p>This guide covers migration from <code>0.2.0-alpha</code> to <code>0.3.0-beta</code>.</p>","path":["Migration Guides","Migration Guide: 0.2.0-alpha to 0.3.0-beta"],"tags":[]},{"location":"migration-guide-0.3.0-beta/#what-changed","level":2,"title":"What Changed","text":"<ul> <li>DeepMatch now discovers multiple spec files per module:<ul> <li>module root: <code>.deeplinks.yml</code> and <code>*.deeplinks.yml</code></li> <li>variant folder: <code>src/&lt;variant&gt;/.deeplinks.yml</code> and <code>src/&lt;variant&gt;/*.deeplinks.yml</code></li> </ul> </li> <li>Sources are merged in deterministic order:<ul> <li>root files first</li> <li>variant files second</li> <li>same spec <code>name</code> in later sources overrides earlier ones</li> </ul> </li> <li>New optional HTML report generation:<ul> <li><code>deepMatch { report { enabled = true } }</code></li> <li>generates a standalone catalogue + URI validator page</li> </ul> </li> <li>Multi-module collision validation is wired into variant build/check.</li> </ul>","path":["Migration Guides","Migration Guide: 0.2.0-alpha to 0.3.0-beta"],"tags":[]},{"location":"migration-guide-0.3.0-beta/#1-audit-spec-file-layout","level":2,"title":"1. Audit Spec File Layout","text":"<p>If your module only has a single <code>.deeplinks.yml</code>, no change is required.</p> <p>If you use multiple files, verify naming and precedence:</p> <ul> <li>Keep shared/default specs in module root files.</li> <li>Put build-type or variant overrides under <code>src/&lt;variant&gt;/</code>.</li> <li>If the same spec <code>name</code> exists in both, variant/build-type overrides root.</li> </ul>","path":["Migration Guides","Migration Guide: 0.2.0-alpha to 0.3.0-beta"],"tags":[]},{"location":"migration-guide-0.3.0-beta/#2-audit-duplicate-spec-names","level":2,"title":"2. Audit Duplicate Spec Names","text":"<p>Duplicate names are now treated differently depending on scope:</p> <ul> <li>Within the same file: build fails (still invalid).</li> <li>Across multiple files: later source overrides earlier source by <code>name</code>.</li> </ul> <p>Action:</p> <ul> <li>Keep intentional overrides only (same <code>name</code>, different variant behavior).</li> <li>Rename accidental collisions so they remain distinct.</li> </ul>","path":["Migration Guides","Migration Guide: 0.2.0-alpha to 0.3.0-beta"],"tags":[]},{"location":"migration-guide-0.3.0-beta/#3-optional-enable-the-deeplink-report","level":2,"title":"3. Optional: Enable the Deeplink Report","text":"<p>Add report config:</p> <pre><code>deepMatch {\n    report {\n        enabled = true\n        // Optional:\n        // output = layout.buildDirectory.file(\"reports/deeplinks.html\")\n    }\n}\n</code></pre> <p>Generate it:</p> <pre><code>./gradlew :app:generateDeeplinkReport\n</code></pre> <p>Use it to validate URIs against specs in-browser without running the app.</p>","path":["Migration Guides","Migration Guide: 0.2.0-alpha to 0.3.0-beta"],"tags":[]},{"location":"migration-guide-0.3.0-beta/#4-expect-collision-validation-during-build","level":2,"title":"4. Expect Collision Validation During Build","text":"<p><code>validate&lt;Variant&gt;CompositeSpecsCollisions</code> now runs in variant build/check for composed projects.</p> <p>If your build starts failing, it usually means two modules declare the same normalized URI shape.</p> <p>Action:</p> <ul> <li>Make URI shapes unique across modules, or</li> <li>Consolidate ownership of overlapping routes in one module.</li> </ul>","path":["Migration Guides","Migration Guide: 0.2.0-alpha to 0.3.0-beta"],"tags":[]},{"location":"migration-guide-0.3.0-beta/#5-optional-use-validatedeeplinks-in-cidebugging","level":2,"title":"5. Optional: Use <code>validateDeeplinks</code> in CI/Debugging","text":"<p>You can validate a URI quickly from Gradle:</p> <pre><code>./gradlew :app:validateDeeplinks --uri='app://example.com/profile/42?ref=promo'\n</code></pre> <p>This is useful for smoke checks without launching the app.</p>","path":["Migration Guides","Migration Guide: 0.2.0-alpha to 0.3.0-beta"],"tags":[]},{"location":"plugin/","level":1,"title":"Plugin","text":"","path":["Plugin"],"tags":[]},{"location":"plugin/#core-capabilities","level":3,"title":"Core Capabilities","text":"<p>The primary responsibilities and capabilities of the DeepMatch Gradle plugin are:</p> <ol> <li> <p>YAML Configuration Parsing:</p> <ul> <li>The plugin automatically locates and reads all deeplink spec files from:<ul> <li>module root: <code>.deeplinks.yml</code> and <code>*.deeplinks.yml</code></li> <li><code>src/&lt;variant&gt;/</code>: <code>.deeplinks.yml</code> and <code>*.deeplinks.yml</code></li> </ul> </li> <li>Sources are merged in deterministic order: root files first, then variant files.<ul> <li>If the same spec <code>name</code> appears in multiple sources, the later source overrides the earlier one.</li> <li>This means a build-type/variant spec overrides a module-root spec with the same <code>name</code>.</li> </ul> </li> <li>It parses the YAML content, validating its structure against the expected format (implicitly defined by how it generates code and manifest entries, aligning with the <code>DeeplinkConfig</code> structure).</li> <li>Each spec must define at least one <code>scheme</code>; <code>host</code> is optional and can be omitted for hostless deeplinks.</li> <li>Spec <code>name</code> values must be unique within the same source file; duplicates fail early with a clear plugin error.</li> </ul> </li> <li> <p>Android Manifest Generation:</p> <ul> <li>Based on the parsed <code>deeplinkSpecs</code> from your YAML file, the plugin dynamically generates the necessary <code>&lt;intent-filter&gt;</code> entries within your app's <code>AndroidManifest.xml</code>.</li> <li>For each <code>DeeplinkConfig</code> entry in your YAML, it creates an <code>&lt;activity&gt;</code> (or merges with an existing one if the <code>activity</code> name matches) and adds an <code>&lt;intent-filter&gt;</code> to it.</li> <li>Path attributes are selected automatically based on spec shape:<ul> <li>static paths -&gt; <code>android:path</code> (with trailing-slash variant)</li> <li>typed-at-end paths -&gt; <code>android:pathPrefix</code></li> <li>typed-in-middle paths -&gt; <code>android:pathPattern</code> (+ <code>android:pathAdvancedPattern</code> when <code>compileSdk &gt;= 31</code>)</li> </ul> </li> <li>Hostless specs omit <code>android:host</code>. When <code>port</code> is declared, <code>android:port</code> is generated.</li> <li>Query params and fragment constraints are not emitted in manifest filters (they are runtime-validated by <code>DeeplinkProcessor</code>).</li> <li>Generated deeplink activities include <code>android:exported=\"true\"</code> and <code>tools:node=\"merge\"</code> for Android 12+ and merge-friendly behavior.</li> <li>This automation means you do not need to manually write or maintain these <code>&lt;intent-filter&gt;</code> tags in your main <code>AndroidManifest.xml</code> for the deep links defined in your YAML. The plugin handles keeping them in sync with your YAML configuration.</li> <li>The generated manifest entries are typically merged into the final manifest during the build process (e.g., visible in <code>app/build/intermediates/merged_manifests/debug/AndroidManifest.xml</code>).</li> </ul> </li> <li> <p>Code Generation (<code>DeeplinkSpecs</code>):</p> <ul> <li>The plugin generates Kotlin source code, most notably a class named something like <code>[DeeplinkName]DeeplinkSpecs</code> (the exact name might vary based on the deeplink name in the <code>.yml</code> file).</li> <li>The plugin also generates a params class for every deeplink spec, including static-only specs.</li> <li>It additionally generates a module-level sealed interface (for example, module <code>app</code> -&gt; <code>AppDeeplinkParams</code>) implemented by all generated params classes, enabling exhaustive <code>when</code> matching in app code.</li> <li>It generates a module-level processor object (for example, module <code>app</code> -&gt; <code>AppDeeplinkProcessor</code>) wired with all generated specs so no manual registration is required.</li> </ul> </li> <li> <p>Integration with Build Process:</p> <ul> <li>The plugin hooks into the Android Gradle Plugin's build lifecycle.</li> <li>Its tasks (like YAML parsing, manifest generation, code generation) typically run before Java/Kotlin compilation, ensuring that the generated code and manifest entries are available when the rest of your app's code (including the codegen process) is processed.</li> <li>For composed multi-module setups, the plugin also validates URI-shape collisions and fails fast when two modules define the same normalized deeplink shape.</li> </ul> </li> <li> <p>Configuration Options:</p> <ul> <li>The plugin provides a DSL (Domain Specific Language) extension in your <code>build.gradle</code> (<code>deepMatch { ... }</code> block) to customize its behavior:<ul> <li>generateManifestFiles: Specifying whether or not the plugin should generate <code>AndroidManifest.xml</code> file based on the deeplink config <code>yaml</code> file.</li> <li>report.enabled: Enables generation of a standalone deeplink HTML report.</li> <li>report.output: Optional output file override for the generated report.</li> </ul> </li> </ul> </li> </ol>","path":["Plugin"],"tags":[]},{"location":"plugin/#benefits-of-using-the-plugin","level":3,"title":"Benefits of Using the Plugin","text":"<ul> <li>Single Source of Truth: Your discovered deeplink YAML sources become the definitive source for all deep link definitions.</li> <li>Reduced Boilerplate: No need to manually write complex and error-prone <code>&lt;intent-filter&gt;</code> tags in the manifest.</li> <li>Consistency: Ensures that your manifest and the runtime parsing logic are always in sync with your declared specifications.</li> <li>Improved Maintainability: Adding, removing, or modifying deep links is as simple as editing the YAML file and rebuilding.</li> <li>Build-Time Checks (Implicit): While not a full validation suite, the parsing step can catch basic syntax errors in your YAML file early in the build process.</li> </ul>","path":["Plugin"],"tags":[]},{"location":"plugin/#getting-started","level":3,"title":"Getting Started","text":"<ol> <li> <p>Apply the plugin alongside your usual Android and Kotlin plugins:</p> <pre><code>plugins {\n    id(\"com.android.application\")\n    id(\"org.jetbrains.kotlin.android\")\n    id(\"com.aouledissa.deepmatch.gradle\") version \"&lt;DEEPMATCH_VERSION&gt;\"\n}\n</code></pre> </li> <li> <p>Configure the extension in the same module:</p> <pre><code>deepMatch {\n    generateManifestFiles = true\n    report {\n        enabled = true\n        // output = layout.buildDirectory.file(\"reports/deeplinks.html\")\n    }\n}\n</code></pre> </li> <li> <p>Add one or more deeplink YAML files:</p> <ul> <li>module root: <code>.deeplinks.yml</code> or <code>*.deeplinks.yml</code></li> <li>variant-specific: <code>src/&lt;variant&gt;/.deeplinks.yml</code> or <code>src/&lt;variant&gt;/*.deeplinks.yml</code>    See <code>deeplink-specs.md</code> for the full schema.</li> </ul> </li> </ol> <p>During the build the plugin generates Kotlin sources under <code>build/generated/</code> and, when enabled, a manifest snippet under <code>build/generated/manifests/&lt;variant&gt;/AndroidManifest.xml</code>. For multi-module behavior and precedence, see Composite Specs.</p>","path":["Plugin"],"tags":[]},{"location":"plugin/#generated-artifacts","level":3,"title":"Generated Artifacts","text":"<ul> <li><code>&lt;ModuleName&gt;DeeplinkParams.kt</code> — module-level sealed interface implemented by generated params classes.</li> <li><code>&lt;ModuleName&gt;DeeplinkProcessor.kt</code> — module-level processor object extending <code>DeeplinkProcessor</code> and preconfigured with all generated specs.   When dependent modules also apply DeepMatch, this generated object extends <code>CompositeDeeplinkProcessor</code> and composes local specs with discovered module processors in order.</li> <li><code>*DeeplinkSpecs.kt</code> — exposes a <code>DeeplinkSpec</code> property per configuration entry.   Generated specs use <code>pathParams</code> as an ordered list to preserve YAML-declared path segment order.</li> <li><code>*DeeplinkParams.kt</code> — params class emitted for every deeplink spec. When a spec has typed values, generated constructor properties are strongly typed.   Query params marked <code>required: true</code> are generated as non-null properties; optional query params are generated as nullable properties.</li> <li>Generated manifest file — contains <code>&lt;intent-filter&gt;</code> definitions that Gradle merges into the final manifest.</li> </ul>","path":["Plugin"],"tags":[]},{"location":"plugin/#available-tasks","level":3,"title":"Available Tasks","text":"<p>Task details are documented in Tasks, including:</p> <ul> <li><code>generate&lt;Variant&gt;DeeplinkSpecs</code></li> <li><code>generate&lt;Variant&gt;DeeplinksManifest</code></li> <li><code>validateDeeplinks</code></li> <li><code>generateDeeplinkReport</code></li> </ul>","path":["Plugin"],"tags":[]},{"location":"plugin/#testing-ci","level":3,"title":"Testing &amp; CI","text":"<pre><code>./gradlew publishToMavenLocal  # Optional; handy when consuming the plugin from another project locally\n./gradlew test                 # Runs JVM tests for the plugin, runtime, and shared fixtures\n</code></pre> <p>Runtime behaviour is validated with Robolectric-based tests in <code>deepmatch-processor/src/test</code>, backed by reusable fakes from the <code>deepmatch-testing</code> module. The GitHub Action workflow (<code>.github/workflows/ci.yml</code>) runs the same <code>test</code> task on every push and pull request; enable branch protection to require the CI workflow before merging.</p>","path":["Plugin"],"tags":[]},{"location":"report/","level":1,"title":"Deeplink Report","text":"<p>DeepMatch can generate a standalone HTML report that combines:</p> <ul> <li>A full catalog merged from discovered local spec files.</li> <li>Catalog views grouped by module and source file when multiple inputs exist.</li> <li>A live URI validator.</li> <li>Near-miss diagnostics (for example, required query param missing).</li> <li>Quick test URI buttons generated from spec examples.</li> </ul> <p>Important</p> <p>The validator runs directly in the generated HTML page, so you can validate URIs against specs without building or running the Android app.</p>","path":["Deeplink Report"],"tags":[]},{"location":"report/#enable","level":2,"title":"Enable","text":"<pre><code>deepMatch {\n    report {\n        enabled = true\n        // Optional override (default: build/reports/deeplinks.html)\n        // output = layout.buildDirectory.file(\"reports/deeplinks.html\")\n    }\n}\n</code></pre>","path":["Deeplink Report"],"tags":[]},{"location":"report/#generate","level":2,"title":"Generate","text":"<pre><code>./gradlew :app:generateDeeplinkReport\n</code></pre>","path":["Deeplink Report"],"tags":[]},{"location":"report/#output","level":2,"title":"Output","text":"<p>Default output:</p> <pre><code>&lt;module&gt;/build/reports/deeplinks.html\n</code></pre> <p>The file is fully self-contained (no external CSS/JS dependencies), so it can be:</p> <ul> <li>Opened locally in a browser.</li> <li>Shared as a single file.</li> <li>Uploaded as a CI artifact.</li> <li>Hosted as a static page.</li> </ul>","path":["Deeplink Report"],"tags":[]},{"location":"report/#validation-behavior","level":2,"title":"Validation Behavior","text":"<p>The report validator mirrors runtime matching semantics:</p> <ul> <li>Case-insensitive scheme/host matching.</li> <li>Structural matching via generated deeplink regex.</li> <li>Query params validated by key (order-independent).</li> <li>Optional query params validated only when present.</li> <li>Required query params produce a near-miss diagnostic when absent.</li> <li>Trailing slashes normalized for path matching.</li> </ul>","path":["Deeplink Report"],"tags":[]},{"location":"report/#input-discovery","level":2,"title":"Input Discovery","text":"<p><code>generateDeeplinkReport</code> uses the same file discovery rules as code generation:</p> <ul> <li>Module root: <code>.deeplinks.yml</code> and <code>*.deeplinks.yml</code></li> <li>Variant folder: <code>src/&lt;variant&gt;/.deeplinks.yml</code> and <code>src/&lt;variant&gt;/*.deeplinks.yml</code></li> </ul> <p>In composed projects, dependency modules that apply DeepMatch are included in the report.</p>","path":["Deeplink Report"],"tags":[]},{"location":"tasks/","level":1,"title":"Generated Tasks","text":"<p>DeepMatch adds Gradle tasks under the <code>deepmatch</code> group.</p>","path":["Generated Tasks"],"tags":[]},{"location":"tasks/#generatevariantdeeplinkspecs","level":2,"title":"<code>generate&lt;Variant&gt;DeeplinkSpecs</code>","text":"<p>Parses discovered deeplink spec files and generates Kotlin sources for a variant.</p> <ul> <li>Generates <code>&lt;ModuleName&gt;DeeplinkParams</code> sealed interface.</li> <li>Generates <code>&lt;ModuleName&gt;DeeplinkProcessor</code> object.</li> <li>Generates one <code>*DeeplinkSpecs</code> property per spec.</li> <li>Generates one <code>*DeeplinkParams</code> class per spec.</li> <li>Reads <code>.deeplinks.yml</code> and <code>*.deeplinks.yml</code> from module root and <code>src/&lt;variant&gt;/</code>.</li> <li>Merges root first, then variant; same-name specs in later sources override earlier ones.</li> </ul> <p>Example:</p> <pre><code>./gradlew :app:generateDebugDeeplinkSpecs\n</code></pre>","path":["Generated Tasks"],"tags":[]},{"location":"tasks/#generatevariantdeeplinksmanifest","level":2,"title":"<code>generate&lt;Variant&gt;DeeplinksManifest</code>","text":"<p>Generates deeplink <code>&lt;intent-filter&gt;</code> entries for a variant.</p> <ul> <li>Available when <code>deepMatch { generateManifestFiles = true }</code>.</li> <li>Writes a generated manifest file under <code>build/generated/manifests/&lt;Variant&gt;/</code>.</li> <li>Output is merged by AGP into the final app manifest.</li> </ul> <p>Example:</p> <pre><code>./gradlew :app:generateDebugDeeplinksManifest\n</code></pre>","path":["Generated Tasks"],"tags":[]},{"location":"tasks/#validatedeeplinks","level":2,"title":"<code>validateDeeplinks</code>","text":"<p>Validates a URI against merged specs from discovered deeplink YAML files.</p> <ul> <li>Requires <code>--uri</code>.</li> <li>Prints <code>[MATCH]</code> and <code>[MISS]</code> per spec.</li> <li>Prints extracted params for matching specs.</li> <li>Useful for local checks and CI debugging.</li> </ul> <p>Example:</p> <pre><code>./gradlew :app:validateDeeplinks --uri='app://example.com/profile/42?ref=promo'\n</code></pre>","path":["Generated Tasks"],"tags":[]},{"location":"tasks/#validatevariantcompositespecscollisions","level":2,"title":"<code>validate&lt;Variant&gt;CompositeSpecsCollisions</code>","text":"<p>Validates URI-shape collisions across composed module specs for a variant.</p> <ul> <li>Collects generated spec-shape metadata from the current module and DeepMatch-enabled dependency modules.</li> <li>Fails the build when two modules declare specs with the same normalized URI shape.</li> <li>Runs automatically as part of variant build/check flow.</li> </ul> <p>Example:</p> <pre><code>./gradlew :app:validateDebugCompositeSpecsCollisions\n</code></pre>","path":["Generated Tasks"],"tags":[]},{"location":"tasks/#generatedeeplinkreport","level":2,"title":"<code>generateDeeplinkReport</code>","text":"<p>Generates a single self-contained HTML report from local specs plus composed dependency-module specs.</p> <ul> <li>Enabled with:</li> <li><code>deepMatch { report { enabled = true } }</code></li> <li>Output defaults to <code>build/reports/deeplinks.html</code>.</li> <li>Output can be overridden with:</li> <li><code>deepMatch { report { output = layout.buildDirectory.file(\"reports/custom.html\") } }</code></li> <li>Includes:</li> <li>Full catalog (combined).</li> <li>Module/file catalog entries when multiple sources are present.</li> <li>Live URI validator.</li> <li>Near-miss diagnostics (for example, missing required query params).</li> <li>Quick test URI buttons generated from specs.</li> <li>Browser-side URI validation against generated specs without running the app.</li> </ul> <p>Example:</p> <pre><code>./gradlew :app:generateDeeplinkReport\n</code></pre>","path":["Generated Tasks"],"tags":[]},{"location":"tasks/#list-tasks","level":2,"title":"List Tasks","text":"<p>To inspect all DeepMatch tasks in a module:</p> <pre><code>./gradlew :app:tasks --group deepmatch\n</code></pre>","path":["Generated Tasks"],"tags":[]},{"location":"release-notes/0.1.0-alpha/","level":1,"title":"DeepMatch 0.1.0-alpha","text":"<ul> <li>Introduced the DeepMatch Gradle plugin (<code>com.aouledissa.deepmatch.gradle</code>) to parse   <code>.deeplinks.yml</code> specs per variant, generate Kotlin sources, and optionally emit Android manifest   entries.</li> <li>Added the DeepMatch Processor runtime library capable of matching URIs, building typed   parameter objects, and dispatching to strongly typed handlers.</li> <li>Published the shared DeepMatch API module containing the spec/parameter data models used   across plugin and runtime.</li> <li>Delivered a reusable DeepMatch Testing module with fake handlers/processors and spec fixtures   for unit test support.</li> </ul>","path":["Release Notes","DeepMatch 0.1.0-alpha"],"tags":[]},{"location":"release-notes/0.2.0-alpha/","level":1,"title":"DeepMatch 0.2.0-alpha","text":"","path":["Release Notes","DeepMatch 0.2.0-alpha"],"tags":[]},{"location":"release-notes/0.2.0-alpha/#highlights","level":2,"title":"Highlights","text":"<ul> <li>Introduced a zero-configuration runtime flow driven by generated code:</li> <li>The plugin now generates a module processor object (for example, <code>AppDeeplinkProcessor</code>).</li> <li>Clients can call <code>match(uri)</code> directly and branch on typed params.</li> <li>Added module-level sealed params generation (for example, <code>AppDeeplinkParams</code>), with generated   <code>*DeeplinkParams</code> implementing this sealed interface for exhaustive <code>when</code> checks.</li> <li>Added a composite-build sample app at <code>samples/android-app</code> demonstrating:</li> <li>generated processor usage in Compose UI,</li> <li>generated manifest deeplink filters,</li> <li>real-device deeplink validation with <code>adb</code>.</li> </ul>","path":["Release Notes","DeepMatch 0.2.0-alpha"],"tags":[]},{"location":"release-notes/0.2.0-alpha/#breaking-changes","level":2,"title":"Breaking Changes","text":"<ul> <li><code>DeeplinkProcessor</code> moved from interface-based builder wiring to an open class configured with specs.</li> <li>Removed:</li> <li><code>DeeplinkHandler</code></li> <li><code>DeeplinkProcessor.Builder</code></li> <li><code>DeeplinkProcessorImpl</code></li> <li>Runtime matching is now return-based:</li> <li><code>match(uri: Uri): DeeplinkParams?</code></li> </ul>","path":["Release Notes","DeepMatch 0.2.0-alpha"],"tags":[]},{"location":"release-notes/0.2.0-alpha/#migration-summary","level":2,"title":"Migration Summary","text":"<ul> <li>Replace builder setup with the generated module processor object.</li> <li>Move deeplink handling logic to caller-side <code>when</code> branching.</li> <li>See the full Migration Guide.</li> </ul>","path":["Release Notes","DeepMatch 0.2.0-alpha"],"tags":[]},{"location":"release-notes/0.3.0-beta/","level":1,"title":"DeepMatch 0.3.0-beta","text":"","path":["Release Notes","DeepMatch 0.3.0-beta"],"tags":[]},{"location":"release-notes/0.3.0-beta/#highlights","level":2,"title":"Highlights","text":"<ul> <li>Added multi-file deeplink spec discovery per module:<ul> <li>module root: <code>.deeplinks.yml</code> and <code>*.deeplinks.yml</code></li> <li>variant folder: <code>src/&lt;variant&gt;/.deeplinks.yml</code> and <code>src/&lt;variant&gt;/*.deeplinks.yml</code></li> </ul> </li> <li>Added deterministic spec merge precedence:<ul> <li>root sources load first</li> <li>variant/build-type sources load second</li> <li>same <code>name</code> in later sources overrides earlier definitions</li> </ul> </li> <li>Added a standalone HTML report (<code>generateDeeplinkReport</code>) with:<ul> <li>full deeplink catalogue</li> <li>source/module-aware catalogue views</li> <li>interactive URI validator</li> <li>near-miss diagnostics and quick test URIs</li> </ul> </li> <li>Added plugin report DSL:<ul> <li><code>deepMatch { report { enabled = true; output = ... } }</code></li> </ul> </li> </ul>","path":["Release Notes","DeepMatch 0.3.0-beta"],"tags":[]},{"location":"release-notes/0.3.0-beta/#behavior-changes","level":2,"title":"Behavior Changes","text":"<ul> <li>Duplicate spec names are still invalid within the same YAML source file.</li> <li>Across multiple YAML sources, same-name specs now resolve by precedence (later source wins).</li> <li>Build-type/variant specs explicitly override module-root specs on same-name collisions.</li> </ul>","path":["Release Notes","DeepMatch 0.3.0-beta"],"tags":[]},{"location":"release-notes/0.3.0-beta/#validation-improvements","level":2,"title":"Validation Improvements","text":"<ul> <li><code>validateDeeplinks</code> now evaluates merged specs from all discovered sources.</li> <li>Composite collision validation remains integrated into variant build/check flow to fail fast on   URI-shape conflicts across composed modules.</li> </ul>","path":["Release Notes","DeepMatch 0.3.0-beta"],"tags":[]},{"location":"release-notes/0.3.0-beta/#docs-and-sample","level":2,"title":"Docs and Sample","text":"<ul> <li>Added report documentation and task references.</li> <li>Updated docs for multi-file discovery and override precedence.</li> <li>Expanded sample app with multiple deeplink source files and report generation usage.</li> </ul>","path":["Release Notes","DeepMatch 0.3.0-beta"],"tags":[]},{"location":"release-notes/0.3.0-beta/#migration","level":2,"title":"Migration","text":"<ul> <li>See Migration Guide for upgrade steps from <code>0.2.0-alpha</code>.</li> </ul>","path":["Release Notes","DeepMatch 0.3.0-beta"],"tags":[]}]}